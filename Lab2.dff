diff --git a/Makefile b/Makefile
index 2535522..daf31e0 100644
--- a/Makefile
+++ b/Makefile
@@ -183,6 +183,7 @@ UPROGS=\
 	_zombie\
 	_hello\
 	_test\
+	_lab2test\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
diff --git a/defs.h b/defs.h
index c3b63cb..a67225e 100644
--- a/defs.h
+++ b/defs.h
@@ -123,6 +123,7 @@ void            yield(void);
 void            exit2(int status);
 int             wait2(int*);
 int             waitpid(int, int*, int);
+void            setpriority(int priority);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/exec.c b/exec.c
index b40134f..eff3a2d 100644
--- a/exec.c
+++ b/exec.c
@@ -99,6 +99,7 @@ exec(char *path, char **argv)
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
+  curproc->T_start = ticks;
   switchuvm(curproc);
   freevm(oldpgdir);
   return 0;
diff --git a/lab2test.c b/lab2test.c
new file mode 100644
index 0000000..269333a
--- /dev/null
+++ b/lab2test.c
@@ -0,0 +1,57 @@
+#include "types.h"
+#include "user.h"
+
+int PScheduler(void);
+
+int main(int argc, char *argv[])
+{
+    PScheduler();
+
+    exit2(0);
+}    
+      
+int PScheduler(void){
+		 
+    // Use this part to test the priority scheduler. Assuming that the priorities range between range between 0 to 31
+    // 0 is the highest priority. All processes have a default priority of 10
+    // You can use your own priority range/value setup
+
+    int pid, ret_pid, exit_status;
+    int i,j,k;
+  
+    printf(1, "Testing the priority scheduler and setpriority system call:\n");
+    printf(1, "Assuming that the priorities range between range between 0 to 31\n");
+    printf(1, "0 is the highest priority. All processes have a default priority of 10\n");
+    printf(1, " - The parent processes will switch to priority 0\n");
+    setpriority(0); // Use your own setpriority interface
+    for (i = 0; i < 3; i++) {
+	pid = fork();
+	if (pid > 0) {
+            continue;
+        } else if ( pid == 0) {
+            printf(1, " - Hello! this is child# %d and I will change my priority to %d \n", getpid(), 60 - 20 * i);
+            setpriority(30 - 10 * i); // Use your own setpriority interface
+            for (j = 0; j < 50000; j++) {
+                asm("nop");
+                for(k = 0; k < 10000; k++) {
+                    asm("nop"); 
+                }
+            }
+            printf(1, " - Child #%d with priority %d has finished! \n", getpid(), 30-10*i);		
+            exit2(0);
+        } else {
+            printf(2," \n Error fork() \n");
+            exit2(-1);
+        }
+    }
+
+    if(pid > 0) {
+        for (i = 0; i < 3; i++) {
+            ret_pid = wait2(&exit_status);
+            printf(1, " - This is the parent: child with PID# %d has finished with status %d \n", ret_pid, exit_status);
+        }
+        printf(1, " - If processes with highest priority finished first then its correct. \n");
+    }
+			
+    return 0;
+}
diff --git a/proc.c b/proc.c
index 0cf744e..c0befd5 100644
--- a/proc.c
+++ b/proc.c
@@ -88,6 +88,7 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->prior_val = 10;
 
   release(&ptable.lock);
 
@@ -199,6 +200,7 @@ fork(void)
   np->sz = curproc->sz;
   np->parent = curproc;
   *np->tf = *curproc->tf;
+  np->prior_val = curproc->prior_val;
 
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
@@ -231,6 +233,14 @@ exit(void)
   struct proc *p;
   int fd;
 
+  //fd
+  curproc->exit_status = 0;
+  curproc->T_finish = ticks;
+  int turnaround = curproc->T_finish - curproc->T_start;
+  int waiting = turnaround - curproc->T_burst_total;
+
+  cprintf("Turnaround time: %d CPU ticks\nWaiting time: %d CPU ticks\n", turnaround, waiting);
+
   if(curproc == initproc)
     panic("init exiting");
 
@@ -279,6 +289,11 @@ exit2(int status)
 
   //cprintf("\n --Status is: %d\n", status );
   curproc->exit_status = status;
+  curproc->T_finish = ticks;
+  int turnaround = curproc->T_finish - curproc->T_start;
+  int waiting = turnaround - curproc->T_burst_total;
+
+  cprintf("Turnaround time: %d CPU ticks\nWaiting time: %d CPU ticks\n", turnaround, waiting);
 
   if(curproc == initproc)
     panic("init exiting");
@@ -344,6 +359,8 @@ wait(void)
         p->name[0] = 0;
         p->killed = 0;
         p->state = UNUSED;
+        p->T_burst_finish = ticks;
+        p->T_burst_total += p->T_burst_finish - p->T_burst_start;
         release(&ptable.lock);
         return pid;
       }
@@ -387,6 +404,8 @@ wait2(int *status)
         p->name[0] = 0;
         p->killed = 0;
         p->state = UNUSED;
+        p->T_burst_finish = ticks;
+        p->T_burst_total += p->T_burst_finish - p->T_burst_start;
         *status = p->exit_status;
         release(&ptable.lock);
         return pid;
@@ -428,6 +447,8 @@ waitpid(int in_pid, int *status, int option) {
         p->name[0] = 0;
         p->killed = 0;
         p->state = UNUSED;
+        p->T_burst_finish = ticks;
+        p->T_burst_total += p->T_burst_finish - p->T_burst_start;
         *status = p->exit_status;
         release(&ptable.lock);
         return pid;
@@ -445,6 +466,12 @@ waitpid(int in_pid, int *status, int option) {
   }
 }
 
+void 
+setpriority(int priority){
+  struct proc *curproc = myproc();
+  curproc->prior_val = priority;
+}
+
 
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
@@ -459,6 +486,7 @@ scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
+  struct proc *top_priority_proc;
   c->proc = 0;
   
   for(;;){
@@ -471,14 +499,33 @@ scheduler(void)
       if(p->state != RUNNABLE)
         continue;
 
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      c->proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
+      // get highest priority
+      // keep track of highest priority proc
+      struct proc *newP;
+      top_priority_proc = p;
+      for(newP = ptable.proc; newP < &ptable.proc[NPROC]; newP++){
+        if(newP->prior_val < top_priority_proc->prior_val && newP->state == RUNNABLE){
+          top_priority_proc = newP;
+        }
+      }
+      
+      c->proc = top_priority_proc;
+      switchuvm(top_priority_proc);
+      top_priority_proc->state = RUNNING;
+      top_priority_proc->T_burst_start = ticks;
+
+      swtch(&(c->scheduler), top_priority_proc->context);
+      
+      // aging
+      for(newP = ptable.proc; newP < &ptable.proc[NPROC]; newP++){
+        if(top_priority_proc == newP){
+          newP->prior_val++;
+        }
+        else {
+          newP->prior_val--;
+        }
+      }
 
-      swtch(&(c->scheduler), p->context);
       switchkvm();
 
       // Process is done running for now.
@@ -522,6 +569,8 @@ yield(void)
 {
   acquire(&ptable.lock);  //DOC: yieldlock
   myproc()->state = RUNNABLE;
+  myproc()->T_burst_finish = ticks;
+  myproc()->T_burst_total += myproc()->T_burst_finish - myproc()->T_burst_start;
   sched();
   release(&ptable.lock);
 }
@@ -573,6 +622,8 @@ sleep(void *chan, struct spinlock *lk)
   // Go to sleep.
   p->chan = chan;
   p->state = SLEEPING;
+  p->T_burst_finish = ticks;
+  p->T_burst_total += p->T_burst_finish - p->T_burst_start;
 
   sched();
 
diff --git a/proc.h b/proc.h
index 1d63868..0813789 100644
--- a/proc.h
+++ b/proc.h
@@ -50,6 +50,12 @@ struct proc {
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
   int exit_status;             // Exit status;
+  int prior_val;               // priority value;
+  int T_start;
+  int T_finish;
+  int T_burst_start;
+  int T_burst_finish;
+  int T_burst_total;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index 54e0cdf..540df3c 100644
--- a/syscall.c
+++ b/syscall.c
@@ -106,6 +106,7 @@ extern int sys_uptime(void);
 extern int sys_exit2(void);
 extern int sys_wait2(void);
 extern int sys_waitpid(void);
+extern int sys_setpriority(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -132,6 +133,7 @@ static int (*syscalls[])(void) = {
 [SYS_exit2]   sys_exit2,
 [SYS_wait2]   sys_wait2,
 [SYS_waitpid] sys_waitpid,
+[SYS_setpriority] sys_setpriority,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index ca2ed4a..4826c3a 100644
--- a/syscall.h
+++ b/syscall.h
@@ -23,3 +23,4 @@
 #define SYS_exit2  22
 #define SYS_wait2  23
 #define SYS_waitpid 24
+#define SYS_setpriority 25
diff --git a/sysproc.c b/sysproc.c
index f4d5e90..3cba46e 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -56,6 +56,15 @@ sys_waitpid(void)
 }
 
 int
+sys_setpriority(void){
+  int priority;
+  
+  if(argint(0, &priority) < 0) return -1;
+  setpriority(priority);
+  return 0;
+}
+
+int
 sys_kill(void)
 {
   int pid;
diff --git a/user.h b/user.h
index fc44218..cc152d7 100644
--- a/user.h
+++ b/user.h
@@ -26,6 +26,7 @@ int uptime(void);
 int exit2(int) __attribute__((noreturn));
 int wait2(int*);
 int waitpid(int pid, int *status, int options);
+int setpriority(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 499915e..ddfbd72 100644
--- a/usys.S
+++ b/usys.S
@@ -32,3 +32,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(setpriority)
